---
title: "Homework2"
author: "Yang Zhao - yz4717"
date: "2023-09-30"
output: 
  github_document:
    toc : True
    toc_depth : 2
---

First of all, I import all the needed packages into the environment and set message = FALSE to avoid receiving the unneccessary messages.

```{r import_function, message=FALSE}
library(tidyverse)
library(readxl)
```

# Question 1

```{r Q1_input_pols}
pols_df = read_csv("pols-month.csv") |> 
  janitor::clean_names() |> 
  separate(mon, "-",into = c("year","month","day")) |> 
  mutate(
    month = case_match(
      month, 
      "01" ~ "jan",
      "02" ~ "feb",
      "03" ~ "mar",
      "04" ~ "apr",
      "05" ~ "may",
      "06" ~ "jun",
      "07" ~ "jul",
      "08" ~ "aug",
      "09" ~ "sep",
      "10" ~ "oct", 
      "11" ~ "nov", 
      "12" ~ "dec")) |> 
  mutate(president = recode(
    prez_gop, "0" = "dem",
    "1" = "gop")) |> 
  select(-prez_gop,-day,-prez_dem)

pols_df|> head()

```
This data frame's size is `r nrow(pols_df)` * `r ncol(pols_df)`


```{r Q1_input_snp,message=FALSE}


snp_df = read_csv("snp.csv",
                  col_types = cols(Date = col_date(format = "%m/%d/%y"))) |> 
  janitor::clean_names() |> 
  separate(date,"/",into=c("month","day","year"))|> 
  select(year,month,close)

snp_df$year = as.numeric(snp_df$year)

snp_df |> 
  mutate(
    year = ifelse(year<=15 ,year+2000,year+1900)
  ) |> 
  arrange(year,month)

snp_df |> head()
```


```{r Q1_input_umploy, message=FALSE}
umploy_df = read_csv("unemployment.csv") |> 
  janitor::clean_names() |> 
  pivot_longer(jan:dec,
               names_to = "month",
               values_to = "umploy")

umploy_df |> head()
```


```{r Q1_merging_df_Q1}
pols_df$year = as.double(pols_df$year)
snp_df$year = as.double(snp_df$year)

merged_df = pols_df |>
  left_join(snp_df) |> 
  left_join(umploy_df)

merged_df |> head()
```


# Question 2
```{r Q2_input_mrt}

mrt_df = read_excel(
    "202309 Trash Wheel Collection Data.xlsx",
  cell_cols("A:N"),
  sheet = "Mr. Trash Wheel") |> 
  janitor::clean_names() |> 
  drop_na(dumpster) |> 
  mutate(homes_powered = weight_tons*500/30,
         wheel = c("mr"))|> 
  relocate(wheel,dumpster,year,month)

mrt_df$year = as.double(mrt_df$year)

```

```{r Q2_input_prof}

proft_df = read_excel(
  "202309 Trash Wheel Collection Data.xlsx",
  range = cell_cols("A:M"),
  sheet = "Professor Trash Wheel") |> 
  janitor::clean_names() |> 
  drop_na(dumpster) |> 
  mutate(homes_powered = weight_tons*500/30,
         wheel = c("prof"))|> 
  relocate(wheel,dumpster,year,month)


head(proft_df)
```

In professor's collection data, the total weight of Professor can be calculated by summing up all the weight. So its total weight is `r sum(pull(proft_df,weight_tons))` 

```{r Q2_input_gwy}

gwyt_df = read_excel(
  "202309 Trash Wheel Collection Data.xlsx",
  range = cell_cols("A:K"),
  sheet = "Gwynnda Trash Wheel") |> 
  janitor::clean_names() |> 
  drop_na(dumpster) |> 
  mutate(homes_powered = weight_tons*500/30,
         wheel = c("gwy"))|> 
  relocate(wheel,dumpster,year,month) 


head(gwyt_df)

```

The total collection of cigarette butts collected by Gwynnda in July of 2021 is accounts for`r sum(head(gwyt_df,5)$cigarette_butts)` and it can be calculated by 

```{r Q2_merged}
q2_merged = bind_rows(gwyt_df,mrt_df,proft_df) |> 
  separate(date,"-",into = c("year1","month1","day")) |> 
  select(-year1,-month1) |> 
  relocate(year,month,day) |> 
  arrange(year,month,day)

head(q2_merged)
```

# Question 3

```{r Q3_inut_baseline}
base_df = read_csv("MCI_baseline.csv",skip = 1) |> 
  janitor::clean_names() |> 
  mutate(sex = case_match(sex,
                          1 ~ "male",
                          0 ~ "female"),
         apoe4 = case_match(apoe4,
                            1 ~ "carrier",
                            0 ~ "non_carrier")) |> 
  filter(current_age < age_at_onset | 
           age_at_onset==".") |> 
  mutate(age_at_onset = ifelse(age_at_onset == ".", NA, age_at_onset))

base_df_ori = read_csv("MCI_baseline.csv",skip = 1) |> 
  janitor::clean_names()

head(base_df)
```

There are some definitions above the whole table in the data of **MCI_baseline**, so when we need to import data into the environment, we need to skip the first row and convert the variables' name into lower case.Then,I recode the variable of "**sex**" and "**apoe4**" as the given definitions showed to obtain a more readable data frame. After that, we have to use "**filter**" to select the observations that meet up our requirements.

As requested, my calculation shows above:

* The size of recruited participants is `r nrow(base_df_ori)`
* The size of population with **MCI** is `r sum(!is.na(base_df$age_at_onset))`
* Their average age is `r mean(pull(base_df,current_age))`
* There are `r sum(base_df$sex =="female" & base_df$apoe4 == "carrier")/sum(base_df$sex == "female")*100`% women who will carry the APOE4.

```{r Q3_input_amyloid, message=FALSE}
amy_df = read_csv("mci_amyloid.csv",skip = 1) |> 
  janitor::clean_names() |> 
  rename("id" = "study_id") |> 
  pivot_longer(baseline:time_8,
               names_to = "time",
               values_to = "value") |> 
  mutate(time = case_match(
    time,
    "baseline" ~ 0,
    "time_2" ~ 2,
    "time_4" ~ 4,
    "time_6" ~ 6,
    "time_8" ~ 8
  ))

```

In the data of **mci_amyloid**, we can see a definition is being displayed on the top of document. To make a more tidier version of data frame, we need to skip the first row of this data. After that, I converted all the variables' name into lower case and use "rename()" function to rename the variable "study_id". Then, I reshape the provided data frame from a wider format to a longer format.To get a tidire version of given data, I also change the expression of the specific time node.

```{r Q3_combine_data}
q3_only1 = anti_join(base_df,amy_df, by= "id")
q3_only2 = anti_join(amy_df,base_df, by= "id")
q3_merged_df = inner_join(base_df,amy_df,by = "id")
```

The first result of "anti_join" will provide a data frame containing all the rows from **base_df** that do not have matching rows in **amy_df** based on the specified columns used for comparison, and vice versa, the scond one will provide a data frame containing all the rows from **amy_df** that do not have matching rows in **base_df** based on the specified columns used for comparison.

```{r}
q3_only1 |> head()
q3_only2 |> head()
```
I diplayed part of the result of anti_join. It's clear that some participants appear in only the baseline or amyloid datasets. Due to the limitation of this graph, I opt to show part of the result.Based on my observations from data set,the participants ,appeared in **amyloid only**, have a complete records about their amyloid condition. And people who appeared in **baseline** only tend to be non carrier of APOE4. 

